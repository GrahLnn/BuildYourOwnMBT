/// ================================================================================
/// # 倒数第二章：检查整个程序
///
/// 🎉 **祝贺你！你已经到达了类型检查阶段的重要里程碑！** 🎉
///
/// 我们已经分别构建了用于检查表达式、语句、函数和结构体的所有组件。
/// 现在，是时候将它们全部整合起来，在 `typecheck/program.mbt` 中实现最终的入口函数 `check_program`，
/// 它将负责对整个程序进行完整的类型检查。
///
/// ## 🎯 你的任务：实现 `check_program`
///
/// `check_program` 函数是整个类型检查阶段的总指挥。它的核心是采用一个经典的两阶段（Two-Pass）策略来解决前向引用（Forward Reference）和互相递归的问题。
///
/// ### 💡 实现思路：两阶段检查（Two-Pass Checking）
///
/// **第一阶段：注册（Registration Pass）**
///
/// 在真正检查任何函数体或表达式之前，我们首先需要“总览”整个程序，了解所有顶层定义的名字和“签名”。
///
/// 1.  **注册结构体：**
///     *   实现一个 `collect_struct_names` 辅助函数。
///     *   遍历程序中所有的 `struct` 定义，将它们的名字（`name`）记录到 `Context` 的 `struct_defs` 表中。此时，我们只关心名字，不关心其内部字段。
///
/// 2.  **注册函数和全局变量：**
///     *   实现一个 `collect_function_types` 辅助函数。
///     *   遍历所有顶层的 `fn` 定义。对于每一个函数，转换其参数和返回值的类型，构造出 `Function` 类型，然后将其名字和类型签名存入 `Context` 的 `func_types` 和全局 `type_env` 中。
///     *   同样，遍历所有顶层的 `let` 绑定，检查其类型并存入全局 `type_env`。
///
/// > 完成第一阶段后，`Context` 就有了一张“全局符号表”，知道了程序中所有顶层“有什么”，即使我们还没检查它们“做什么”。
///
/// **第二阶段：检查（Checking Pass）**
///
/// 现在，所有定义都已“备案”，我们可以开始真正的检查了。
///
/// 1.  在 `check_program` 函数中，按顺序调用你之前实现的检查函数：
/// 2.  遍历并调用 `check_struct_def` 检查每个结构体的字段类型。
/// 3.  遍历并调用 `check_top_let` 检查每个全局 `let` 绑定的表达式。
/// 4.  遍历并调用 `check_top_function` 检查每个顶层函数的函数体。由于所有函数签名都已在第一阶段注册，函数间的互相调用和递归调用此时都可以被正确地检查。
///
/// ---
///
/// ### 🚀 见证你的成果！
///
/// 完成 `check_program` 后，你就拥有了一个功能完备的 MiniMoonBit 类型检查器！
///
/// **再次祝贺你完成了这一重要的里程碑！接下来，我们将进入类型检查的最终阶段！**
///
/// ---
///
/// **阶段性测试：**
///
/// ```bash
/// moon test -p typecheck -f typecheck_program_test.mbt
/// ```
/// ================================================================================

///|
test "Program TypeCheck Test" {
  let code =
    #|let a = 3;
    #|let b = 4;
    #|fn fold(arr: Array[Int], f: (Int, Int) -> Int, init: Int) -> Int { 
    #|  let mut result = init;
    #|  let mut i = 0; 
    #|  while i < arr.length() {
    #|    result = f(result, arr[i]);
    #|  }
    #|  result
    #|}
    #|
    #|fn main {
    #|  fn max(a, b) { if a > b { a } else { b } }
    #|  fn min(a, b) { if a < b { a } else { b } }
    #|  let numbers = [a, 1, b, 1, 5, 9, 2, 6, 5];
    #|  let maximum = fold(numbers, max, -1000);
    #|  let minimum = fold(numbers, min, 1000);
    #|  let max_min_diff = maximum - minimum;
    #|  print_int(max_min_diff);
    #|}
  let ctx = Context::new()
  ctx.type_env.set("print_int", Type::{
    kind: Function([Int], Unit),
    mutable: false,
  })
  ctx.func_types.set("print_int", Function([Int], Unit))
  // Type check the program
  let tokens = @lexer.tokenize(code)
  let program = @parser.parse(tokens)
  let _ = ctx.check_program(program)

}
